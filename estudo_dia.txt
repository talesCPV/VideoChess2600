22/06
    return_pos_list(list,tab):
        list = [[x,y,('cor','tipo da peça, ex: D')], ...] #lista de posições
        tab = [lista das posições do tabuleiro] #tabuleiro
        return_pos_list recebe os parâmetros acima e retorna uma lista com as posições e retorna
          uma lista com as posições possíveis de cada item de 'list'

    check_risk(casa,lista)
        casa = (x,y)
        lista = [[[(x,y)],x, y, 'cor','peca'], ...], onde os primeiros (x,y) são a casa onde pretende ir e o segundo é a sua peça, se retornar uma lista vazia  esta ok


    runaway(peca,tab)
        peca = [x,y]
        tab = [tabuleiro]
        1) buscar no tab as informações da posição x,y
        2) montar uma variável list=[[x,y,('cor','peca')]]
        3) chamar return_pos_list(list,tab) e salvar as possibilidades numa lista
        4) varrer esta lista passando para check_risk(casa,lista)
        5) assim que achar uma casa segura (check_risk retornar []), efetuar o movimento

        PS: NA FUNÇÃO RUNWAY, FALTA VERIFICAR A LISTA DE POSSIBILIDADES SE TODAS SÃO SEGURAS

24/06
    simula_jogada(tab, jogada)
        tab = tabuleiro
        jogada = [pos inicial , pos final]

        1) new_tab = cópia de tab, sem vínculo
        2) faz o movimento (jogada) em new_tab

        Simula jogada finalizado

        PS: Quando sua peça é ameaçada por mais de uma peça ela analiza a melhor saída e executa.

26/06
    alteração em runaway: verificação se 'list' não ficou zerada após 'return_pos_list'
    Acho que terminei a defesa, tem que testar bastante e depois programar o ataque


28/06
    Começo dos estudos de ataque:
        1) achar a casa do rei adversário
        2) varrer suas peças e ver quantas jogadas são necessárias até a posição de xeque no adversário
         (PS: deixar o peão de fora desta etapa)
        3) varrer suas peças e ver quantos movimentos serão necessários até proteger a sua peça que dará xeque no adversário

02/07
    Mudança de estratégia no ataque:
        1) Strike agora recebe além do tab, as jogadas possíveis da CPU
        2) Varrendo as jogadas possíveis da CPU, analisar se alguma alcança uma peça branca
        3) Se alvançar ele simula a jogada e vê se é seguro, se for executa. (ataque seguro)

03/07
    Alterações de ataque:
        1) Reposicionamento do ataque seguro para uma nova função (tirei os flags)
        2) Se não existir nenhuma peça que possa ser abatida em segurança vamos pensar em uma jogada criativa
        3) Separei as jogadas dos peões com as jogadas das demais peças.
        4) Se as jogadas de peças forem poucas, vamos abrir os peões (usei um random nas jogadas dos peões)
04/07
    Que comecem os jogos!!!
        1) Alteração de jogada, agora só se pode mexer com as brancas e o computador sempre joga após a sua jogada
        2) Após as jogadas dos peões, o computador começa a jogar com as peças
        3) Análise de qual peça pode chegar mais longe e faz essa jogada
08/07
    Adicionado Roque Branco e Preto

09/07
    Melhorar os módulos
        1) Criar um módulo screen, onde se monta a tela e cria as possibilidades